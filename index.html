<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>DFPWM Stream Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: sans-serif;
      padding: 1rem;
    }

    button,
    input[type="range"] {
      font-size: 1rem;
      margin: 0.5rem 0;
    }

    #status {
      margin: 1rem 0;
    }

    label {
      display: block;
      margin-top: 1rem;
    }
  </style>
</head>

<body>
  <h1>DFPWM Stream Player</h1>
  <button id="connect">Connect</button>
  <button id="disconnect" disabled>Disconnect</button>
  <button id="playpause" disabled>Pause</button>
  <label>
    Volume:
    <input type="range" id="volume" min="0" max="1" step="0.01" value="1">
  </label>
  <div id="status">Status: Idle</div>

  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js');
    }
    class DFPWMDecoder {
      constructor() {
        this.PREC = 10; this.POSTFILT = 140;
        this.fq = 0; this.q = 0; this.s = 0; this.lt = -128;
      }
      decode(data) {
        const { PREC, POSTFILT } = this;
        const out = new Float32Array(data.length * 8);
        let op = 0;
        for (let i = 0; i < data.length; i++) {
          let d = data[i];
          for (let b = 0; b < 8; b++, op++) {
            const t = (d & 1) ? 127 : -128;
            d >>= 1;
            const oldQ = this.q;
            let nq = this.q + (((this.s * (t - this.q)) + (1 << (PREC - 1))) >> PREC);
            if (nq === this.q && nq !== t) nq += (t === 127 ? 1 : -1);
            this.q = nq;
            const st = (t !== this.lt ? 0 : (1 << PREC) - 1);
            if (this.s !== st) this.s += (st ? 1 : -1);
            if (this.s < (1 << (PREC - 7))) this.s = (1 << (PREC - 7));
            let ov = (t !== this.lt ? ((nq + oldQ + 1) >> 1) : nq);
            this.fq += ((POSTFILT * (ov - this.fq) + 0x80) >> 8);
            out[op] = this.fq / 128;
            this.lt = t;
          }
        }
        return out;
      }
    }

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const decoder = new DFPWMDecoder();
    const volumeNode = audioCtx.createGain();
    volumeNode.gain.value = 1;
    volumeNode.connect(audioCtx.destination);

    let ws = null;
    let nextPlayTime = 0;
    let isPlaying = true;
    const SAMPLE_RATE = 48000;
    const CHUNK_DURATION = 0.1; // seconds

    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connect');
    const disconnectBtn = document.getElementById('disconnect');
    const playpauseBtn = document.getElementById('playpause');
    const volumeSlider = document.getElementById('volume');

    function updateStatus(msg) {
      statusEl.textContent = 'Status: ' + msg;
    }

    async function startStreaming() {
      await audioCtx.resume();
      connectBtn.disabled = true;
      disconnectBtn.disabled = false;
      playpauseBtn.disabled = false;
      playpauseBtn.textContent = 'Pause';
      updateStatus('Connecting…');
      nextPlayTime = audioCtx.currentTime + CHUNK_DURATION;
      setupWebSocket();
    }

    function stopStreaming() {
      if (ws) {
        ws.close();
        ws = null;
      }
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
      playpauseBtn.disabled = true;
      updateStatus('Disconnected');
    }

    function togglePlayPause() {
      if (isPlaying) {
        audioCtx.suspend();
        playpauseBtn.textContent = 'Play';
        isPlaying = false;
        updateStatus('Paused');
      } else {
        audioCtx.resume();
        playpauseBtn.textContent = 'Pause';
        isPlaying = true;
        updateStatus('Resumed');
      }
    }

    volumeSlider.oninput = () => {
      volumeNode.gain.value = parseFloat(volumeSlider.value);
    };

    function setupWebSocket() {
      ws = new WebSocket('wss://cc-void-city-radio-piueq.ondigitalocean.app/ws');
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => updateStatus('Connected, streaming…');
      ws.onmessage = evt => {
        const compressed = new Uint8Array(evt.data);
        const pcm = decoder.decode(compressed);
        const buffer = audioCtx.createBuffer(1, pcm.length, SAMPLE_RATE);
        buffer.copyToChannel(pcm, 0);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        src.connect(volumeNode);
        if (nextPlayTime < audioCtx.currentTime) {
          nextPlayTime = audioCtx.currentTime + 0.01;
        }
        src.start(nextPlayTime);
        nextPlayTime += buffer.duration;
      };
      ws.onerror = () => ws.close();
      ws.onclose = () => {
        if (!disconnectBtn.disabled) {
          updateStatus('Connection lost, reconnecting…');
          setTimeout(setupWebSocket, 1000);
        }
      };
    }

    connectBtn.onclick = startStreaming;
    disconnectBtn.onclick = stopStreaming;
    playpauseBtn.onclick = togglePlayPause;
  </script>
</body>

</html>